import { Service } from "typedi";
/**
 * The dependency injection service creates a single instance of a class and stores it globally using the singleton design pattern
 *
 * @category Internal
 */
export class DIService {
    static _instance;
    static _container;
    static get container() {
        return this._container;
    }
    static set container(container) {
        this._container = container;
    }
    static get instance() {
        if (!this._instance) {
            this._instance = new DIService();
        }
        return this._instance;
    }
    _services = new Map();
    static _ServiceSet = new Set();
    /**
     * Get all the services from the DI container
     */
    static get allServices() {
        return DIService._ServiceSet;
    }
    addService(classType) {
        const clazz = classType;
        DIService._ServiceSet.add(clazz);
        if (DIService.container) {
            if (this.isTsyringe(DIService.container)) {
                DIService.container.registerSingleton(clazz);
            }
            else {
                /*
                  TypeDI classes MUST use @Service(), setting it on the container ONLY apply to tokenization, this is BY design.
                  we call the decorator directly here.
                 */
                Service()(clazz);
            }
        }
        else {
            const instance = new clazz();
            this._services.set(clazz, instance);
        }
    }
    getService(classType) {
        const clazz = classType;
        if (DIService.container) {
            if (this.isTsyringe(DIService.container)) {
                return DIService.container.resolve(clazz);
            }
            return DIService.container.get(classType);
        }
        return this._services.get(classType);
    }
    isTsyringe(diContainer) {
        return "registerSingleton" in diContainer;
    }
}
//# sourceMappingURL=index.js.map